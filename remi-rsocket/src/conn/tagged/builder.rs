use rsocket_proto::frame::StreamId;
use rsocket_proto::io::codec::{FragmentedFrameCodec, FrameCodec};
use tokio::io::{AsyncRead, AsyncWrite};
use tokio_util::codec::Framed;

const DEFAULT_CONN_BUF: usize = 8;
const DEFAULT_STREAM_BUF: usize = 4;

/// A builder for [`super::RawConnection`].
#[derive(Debug, Clone)]
pub struct TaggedConnectionBuilder {
    conn_buf: usize,
    stream_buf: usize,
}

impl TaggedConnectionBuilder {
    /// Creates a new instance of [`RawConnectionBuilder`] with default values.
    ///
    /// Default values are as follows:
    /// - Connection Buffer: 8
    /// - Stream Buffer: 4
    #[inline]
    pub const fn new() -> Self {
        Self {
            conn_buf: DEFAULT_CONN_BUF,
            stream_buf: DEFAULT_STREAM_BUF,
        }
    }

    /// Sets the size of the connection buffer of connections built by this
    /// builder.
    ///
    /// Connection buffer is the buffer that holds received frames before they
    /// are sent to streams.
    #[inline]
    pub fn connection_buffer(&mut self, conn_buf: usize) -> &mut Self {
        self.conn_buf = conn_buf;
        self
    }

    /// Sets the size of the buffer of streams generated by connections built by
    /// this builder.
    ///
    /// Stream buffer is the buffer that holds received frames before they are
    /// sent to the user. Each stream has its own buffer, which enables
    /// backpressure on a per-stream basis.
    #[inline]
    pub fn stream_buffer(&mut self, stream_buf: usize) -> &mut Self {
        self.stream_buf = stream_buf;
        self
    }

    /// Builds a [`super::TaggedConnection`] with the given connection.
    ///
    /// # Parameters
    /// - `conn` - The connection to wrap.
    pub fn build<T>(&mut self, conn: T) -> super::UnfragmentedConnection<T>
    where
        T: AsyncRead + AsyncWrite + Unpin,
    {
        let inner = Framed::new(conn, FrameCodec::default());
        let (mux_tx, mux_rx) = rexer::Mux::new(self.conn_buf, self.stream_buf);

        super::TaggedConnection {
            inner,
            mux_tx,
            mux_rx,
        }
    }

    /// Builds a [`super::TaggedConnection`] with the given connection, with
    /// fragmentation support.
    ///
    /// # Parameters
    /// - `conn` - The connection to wrap.
    pub fn build_fragmented<const MTU: usize, T>(
        &mut self,
        conn: T,
    ) -> super::FragmentedConnection<MTU, T>
    where
        T: AsyncRead + AsyncWrite + Unpin,
    {
        let inner = Framed::new(conn, FragmentedFrameCodec::<MTU>::default());
        let (mux_tx, mux_rx) = rexer::Mux::new(self.conn_buf, self.stream_buf);

        super::TaggedConnection {
            inner,
            mux_tx,
            mux_rx,
        }
    }
}
